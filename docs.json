[{"name":"Markdown.Block","comment":"\n\n@docs Block\n@docs HeadingLevel, headingLevelToInt\n\n\n### List Items\n\n@docs ListItem, Task\n\n\n## HTML\n\n@docs Html\n\nSee <Markdown.Html> for more.\n\n\n## Inlines\n\n@docs Inline\n@docs HtmlAttribute\n@docs extractText\n\n","unions":[{"name":"Block","comment":" This is the AST (abstract syntax tree) that represents your parsed markdown.\n\nIn the simplest case, you can pass this directly to a renderer:\n\n    module Main exposing (main)\n\n    import Markdown.Block exposing (Block)\n    import Markdown.Parser\n\n    markdown : String\n    markdown =\n        \"# This is a title!\\n\\nThis is the body.\"\n\n    astResult : Result (List (Advanced.DeadEnd String Parser.Problem)) (List Block)\n    astResult =\n        markdown\n            |> Markdown.Parser.parse\n\n    main : Html msg\n    main =\n        case astResult of\n            Ok ast ->\n                Markdown.Parser.renderDefaultHtml ast\n\n            Err errors ->\n                Html.text \"Encountered parsing errors.\"\n\n","args":[],"cases":[["HtmlBlock",["Markdown.Block.Html Markdown.Block.Block"]],["UnorderedList",["List.List (Markdown.Block.ListItem Markdown.Block.Inline)"]],["OrderedList",["Basics.Int","List.List (List.List Markdown.Block.Inline)"]],["BlockQuote",["List.List Markdown.Block.Block"]],["Heading",["Markdown.Block.HeadingLevel","List.List Markdown.Block.Inline"]],["Paragraph",["List.List Markdown.Block.Inline"]],["CodeBlock",["{ body : String.String, language : Maybe.Maybe String.String }"]],["ThematicBreak",[]]]},{"name":"HeadingLevel","comment":" TODO\n","args":[],"cases":[["H1",[]],["H2",[]],["H3",[]],["H4",[]],["H5",[]],["H6",[]]]},{"name":"Html","comment":"\n\n\n## `HtmlComment`s\n\n`HtmlComment`s contain the raw comment text, completely unprocessed. That means\nyou'll need to trim it if you want to strip the leading or trailing whitespace.\n\nRenderer's do not process `HtmlComment`s. If you want to do any special processing\nbased on HTML comments, you can inspect the `Markdown.Block.Block`s before rendering\nit and perform any special processing based on that. You could even add or remove\n`Block`s, for example, based on the presence of certain comment values.\n\n","args":["children"],"cases":[["HtmlElement",["String.String","List.List Markdown.Block.HtmlAttribute","List.List children"]],["HtmlComment",["String.String"]],["ProcessingInstruction",["String.String"]],["HtmlDeclaration",["String.String","String.String"]],["Cdata",["String.String"]]]},{"name":"Inline","comment":" TODO an inline\n","args":[],"cases":[["HtmlInline",["Markdown.Block.Html Markdown.Block.Block"]],["Link",["String.String","Maybe.Maybe String.String","List.List Markdown.Block.Inline"]],["Image",["String.String","Maybe.Maybe String.String","List.List Markdown.Block.Inline"]],["Emphasis",["List.List Markdown.Block.Inline"]],["Strong",["List.List Markdown.Block.Inline"]],["CodeSpan",["String.String"]],["Text",["String.String"]],["HardLineBreak",[]]]},{"name":"ListItem","comment":" The value for an unordered list item, which may contain a task.\n","args":["children"],"cases":[["ListItem",["Markdown.Block.Task","List.List children"]]]},{"name":"Task","comment":" A task (or no task), which may be contained in a ListItem.\n","args":[],"cases":[["NoTask",[]],["IncompleteTask",[]],["CompletedTask",[]]]}],"aliases":[{"name":"HtmlAttribute","comment":" TODO\n","args":[],"type":"{ name : String.String, value : String.String }"}],"values":[{"name":"extractText","comment":" Extract the text from a list of inlines.\n\n    inlines : List (Inline)\n    inlines =\n        [ Text \"Heading with \"\n        , Emphasis 1\n            [ Text \"emphasis\" ]\n        ]\n\n    extractText inlines == \"Heading with emphasis\"\n\n    -- Original string: \"Heading with *emphasis*\"\n\n","type":"List.List Markdown.Block.Inline -> String.String"},{"name":"headingLevelToInt","comment":" TODO\n","type":"Markdown.Block.HeadingLevel -> Basics.Int"}],"binops":[]},{"name":"Markdown.Html","comment":"\n\n@docs Renderer\n\n\n## Creating an HTML renderer\n\n@docs tag, withAttribute, withOptionalAttribute\n@docs map, oneOf\n\n","unions":[],"aliases":[{"name":"Renderer","comment":" A `Markdown.Html.Renderer` is how you register the list of\nvalid HTML tags that can be used in your markdown. A `Renderer`\nalso defines how to render those tags that it accepts.\n\nUsing an HTML renderer feels similar to building a JSON decoder.\nYou're describing what kind of data you expect to have. You\nalso provide functions that tell what to do with those bits of data.\n\nFor example, if you expect to have an attribute called `button-text` for the\n`<signup-form ...>` tags in your Markdown, you could use the value of the\n`button-text` attribute to render your `<signup-form` like so\n\n","args":["a"],"type":"Markdown.HtmlRenderer.HtmlRenderer a"}],"values":[{"name":"map","comment":" Map the value of a `Markdown.Html.Renderer`.\n","type":"(a -> b) -> Markdown.Html.Renderer a -> Markdown.Html.Renderer b"},{"name":"oneOf","comment":" Usually you want to handle a list of possible HTML\ntags, not just a single one. So 99% of the time you'll\nbe using this function when you use this module.\n\n    htmlRenderer =\n        Markdown.Html.oneOf\n            [ Markdown.Html.tag \"contact-button\"\n                (\\children -> contactButtonView)\n            , Markdown.Html.tag \"signup-form\"\n                (\\children -> signupFormView children)\n            ]\n\n","type":"List.List (Markdown.Html.Renderer view) -> Markdown.Html.Renderer view"},{"name":"tag","comment":" Start a Renderer by expecting a tag of a particular type.\n\n    Markdown.Html.tag \"contact-button\"\n        (\\children ->\n            -- we don't want to use any inner markdown\n            -- within <contact-button> tags, so we'll\n            -- ignore this argument\n            Html.button\n         -- ... fancy SVG and mailto links here\n        )\n\n","type":"String.String -> view -> Markdown.Html.Renderer view"},{"name":"withAttribute","comment":" Expects an attribute. The `Renderer` will fail if that attribute doesn't\nexist on the tag. You can use the values of all the expected tags in the function\nyou define for the tag's renderer.\n\n    import Html\n    import Html.Attributes as Attr\n    import Markdown.Html\n\n    Markdown.Html.tag \"contact-button\"\n        (\\children buttonText color ->\n            Html.button\n                [ Attr.style \"background-color\" color ]\n                [ Html.text buttonText ]\n        )\n        |> Markdown.Html.withAttribute \"button-text\"\n        |> Markdown.Html.withAttribute \"color\"\n\n","type":"String.String -> Markdown.Html.Renderer (String.String -> view) -> Markdown.Html.Renderer view"},{"name":"withOptionalAttribute","comment":" Same as `withAttribute`, but the Renderer won't fail if the attribute is missing.\nInstead, it just returns `Nothing` for missing attributes.\n\n    import Html\n    import Html.Attributes as Attr\n    import Markdown.Html\n\n    Markdown.Html.tag \"bio\"\n        (\\name twitter github children ->\n            bioView name twitter github children\n        )\n\n","type":"String.String -> Markdown.Html.Renderer (Maybe.Maybe String.String -> view) -> Markdown.Html.Renderer view"}],"binops":[]},{"name":"Markdown.Parser","comment":"\n\n@docs parse, deadEndToString\n\n","unions":[],"aliases":[],"values":[{"name":"deadEndToString","comment":" Turn a parsing problem into the default String representation.\n","type":"Parser.Advanced.DeadEnd String.String Parser.Problem -> String.String"},{"name":"parse","comment":" Try parsing a markdown String into `Markdown.Block.Block`s.\n\nOften you'll want to render these `Block`s directly:\n\n    render renderer markdown =\n        markdown\n            |> Markdown.parse\n            |> Result.mapError deadEndsToString\n            |> Result.andThen (\\ast -> Markdown.render renderer ast)\n\n    deadEndsToString deadEnds =\n        deadEnds\n            |> List.map deadEndToString\n            |> String.join \"\\n\"\n\nBut you can also do a lot with the `Block`s before passing them through:\n\n  - Transform the `Block`s ([example: make each heading one level deeper](TODO))\n  - Use the blocks to gather metadata about the markdown document ([example: building a table of contents from `Block`s](TODO))\n\n","type":"String.String -> Result.Result (List.List (Parser.Advanced.DeadEnd String.String Parser.Problem)) (List.List Markdown.Block.Block)"}],"binops":[]},{"name":"Markdown.Renderer","comment":"\n\n@docs Renderer, render\n\n@docs defaultHtmlRenderer\n\n","unions":[],"aliases":[{"name":"Renderer","comment":" A record with functions that define how to render all possible markdown blocks.\nThese renderers are composed together to give you the final rendered output.\n\nYou could render to any type you want. Here are some useful things you might render to:\n\n  - `Html` (using the `defaultHtmlRenderer` provided by this module)\n  - Custom `Html`\n  - `Element`s from [`mdgriffith/elm-ui`](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/)\n  - Types from other custom HTML replacement libraries, like [`rtfeldman/elm-css`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/) or [`tesk9/accessible-html`](https://package.elm-lang.org/packages/tesk9/accessible-html/latest/)\n  - Raw `String`s with [ANSI color codes](http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html) for setting rich colors in terminal (CLI) output\n  - Plain text with any formatting stripped away (maybe for a String search feature)\n\n","args":["view"],"type":"{ heading : { level : Markdown.Block.HeadingLevel, rawText : String.String, children : List.List view } -> view, paragraph : List.List view -> view, blockQuote : List.List view -> view, html : Markdown.Html.Renderer (List.List view -> view), text : String.String -> view, codeSpan : String.String -> view, strong : List.List view -> view, emphasis : List.List view -> view, hardLineBreak : view, link : { title : Maybe.Maybe String.String, destination : String.String } -> List.List view -> Result.Result String.String view, image : { alt : String.String, src : String.String, title : Maybe.Maybe String.String } -> Result.Result String.String view, unorderedList : List.List (Markdown.Block.ListItem view) -> view, orderedList : Basics.Int -> List.List (List.List view) -> view, codeBlock : { body : String.String, language : Maybe.Maybe String.String } -> view, thematicBreak : view }"}],"values":[{"name":"defaultHtmlRenderer","comment":" This renders `Html` in an attempt to be as close as possible to\nthe HTML output in <https://github.github.com/gfm/>.\n","type":"Markdown.Renderer.Renderer (Html.Html msg)"},{"name":"render","comment":" Apply a `Markdown.Parser.Renderer` to turn parsed `Block`s into your rendered\nmarkdown view.\n","type":"Markdown.Renderer.Renderer view -> List.List Markdown.Block.Block -> Result.Result String.String (List.List view)"}],"binops":[]}]